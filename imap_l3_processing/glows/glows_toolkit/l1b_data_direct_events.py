"""@package docstring
Author: Marek Strumik, maro at cbk.waw.pl
"""
import json
import copy
import numpy as np
from .constants import VERSION, SUBSECOND_LIMIT
from .funcs import decode_ancillary_parameter, time_sec_subsec_to_utc, time_sec_subsec_to_float64

class L1bDataDirectEvents():
    """
    L1bDataDirectEvents() class for GLOWS-L1b-direct-event data
    """

    def __init__(self):
        """
        Constructor for this class
        """
        self.data = {}

    def _block_header_add_list_of_anc_files(self, anc_input_from_sdc, anc_input_from_instr_team):
        """
        Add list of used ancillary files to block header
        Args:
            anc_input_from_sdc: ancillary input provided by IMAP SDC (general telemetry)
            anc_input_from_instr_team: ancillary input provided by IMAP/GLOWS Instrument Team
        """
        self.data['header']['ancillary_data_files'] = []
        for key in ['conversion_table_for_anc_data']:
            self.data['header']['ancillary_data_files'].append(anc_input_from_instr_team[key])
        #for key in anc_input_from_sdc:
        #    self.data['block_header']['ancillary_data_files'].append(anc_input_from_sdc[key])


    def _convert_ancillary_parameters(self, l1a_data, anc_input_from_instr_team):
        """
        Convert ancillary parameters collected onboard from integer values to physcial
            units
        Args:
            l1a_data: L1a data provided in the form of data field of L1aDataDirectEvents object
            anc_input_from_instr_team: ancillary input provided by IMAP/GLOWS Instrument Team
        """

        # load conversion/decoding table for ancillary parameters collected onboard
        file_handler = open(anc_input_from_instr_team['conversion_table_for_anc_data'], 'r')
        conversion_table = json.load(file_handler)
        file_handler.close()

        # ancillary parameters collected onboard that need to be decoded
        self.data['filter_temperature'] = decode_ancillary_parameter('filter_temperature',
            conversion_table, l1a_data['filter_temperature'])
        self.data['hv_voltage'] = decode_ancillary_parameter('hv_voltage',
            conversion_table, l1a_data['hv_voltage'])
        self.data['spin_period'] = decode_ancillary_parameter('spin_period',
            conversion_table, l1a_data['spin_period'])
        self.data['spin_phase_at_next_pps'] = decode_ancillary_parameter('spin_phase',
            conversion_table, l1a_data['spin_phase_at_next_pps'])

    def create_l1b_from_l1a_data(self, l1a, anc_input_from_sdc, anc_input_from_instr_team):
        """
        Sets values of L1b fields using L1a data read from a file
        Args:
            l1a_data: L1a data provided in the form of L1aDataDirectEvents object
            anc_input_from_sdc: ancillary input provided by IMAP SDC (general telemetry)
            anc_input_from_instr_team: ancillary input provided by IMAP/GLOWS Instrument Team
        """
        self.data['header'] = {
            'ground_software_version': VERSION,
            'pkts_file_name': l1a.data['header']['pkts_file_name'],
            'seq_count_in_pkts_file': l1a.data['header']['seq_count_in_pkts_file'],
            'l1a_file_name': l1a.data['l1a_file_name']
        }

        # add list of used ancillary files to block_header
        self._block_header_add_list_of_anc_files(anc_input_from_sdc, anc_input_from_instr_team)

        #self.data['unique_identifier'] = \
        #    time_sec_subsec_to_utc(l1a.data['data_every_second']['imap_sclk_last_pps'],
        #                           0).strftime('%Y-%m-%dT%H:%M:%S')

        # TMP_SOLUTION: for now we use imap_start_time_seconds for unique_identifier
        # becasue FSW has a bug that leads to a discrepancy between ['imap_start_time_seconds']
        # and ['data_every_second']['imap_sclk_last_pps']
        self.data['unique_identifier'] = \
            time_sec_subsec_to_utc(l1a.data['imap_start_time_seconds'],
                                   0).strftime('%Y-%m-%dT%H:%M:%S')

        # set IMAP and GLOWS time fields
        self.set_times(l1a.data)

        # set number of completed spins
        self.data['number_of_completed_spins'] = \
            l1a.data['data_every_second']['number_of_completed_spins']

        # convert ancillary parameters collected onboard to physical units
        self._convert_ancillary_parameters(l1a.data['data_every_second'], anc_input_from_instr_team)

        # add flags set onboard to self.data['flags']
        self.data['flags'] = {}
        for key in ['catbed_heater_active', 'spin_period_valid', 'spin_phase_at_next_pps_valid',
                    'spin_period_source', 'glows_time_on_pps_valid', 'time_status_valid',
                    'housekeeping_valid', 'is_pps_autogenerated', 'hv_test_in_progress',
                    'pulse_test_in_progress', 'memory_error_detected']:
            if key[:3] != 'is_':
                self.data['flags']['is_' + key] = l1a.data['data_every_second'][key]
            else:
                self.data['flags'][key] = l1a.data['data_every_second'][key]

        if np.shape(l1a.direct_events)[0] > 0:
            if l1a.direct_events.ndim > 1: # this is supposed to check if we have more than one DE
                self.data['direct_event_glows_times'] = (l1a.direct_events[:, 0] + \
                    l1a.direct_events[:, 1]/SUBSECOND_LIMIT).astype(float)
            else:
                self.data['direct_event_glows_times'] = (l1a.direct_events[0] + \
                    l1a.direct_events[1]/SUBSECOND_LIMIT).astype(float)

            # load conversion/decoding table for ancillary parameters collected onboard
            file_handler = open(anc_input_from_instr_team['conversion_table_for_anc_data'], 'r')
            conversion_table = json.load(file_handler)
            file_handler.close()

            # convert pulse lengths into physical units
            if l1a.direct_events.ndim > 1: # this is supposed to check if we have more than one DE
                self.data['direct_event_pulse_lengths'] = decode_ancillary_parameter('pulse_length',
                    conversion_table, l1a.direct_events[:, 2])
            else:
                self.data['direct_event_pulse_lengths'] = decode_ancillary_parameter('pulse_length',
                    conversion_table, l1a.direct_events[2])
        else:
            self.data['direct_event_glows_times'] = np.array([])
            self.data['direct_event_pulse_lengths'] = np.array([])

    def save_data_to_file(self):
        """
        Save generated L1b data to a file
        """
        # TMP_SOLUTION currently JSON format is used, it needs to be changed to CDF when python-cdf
        # modules for IMAP will be provided by SDC
        self._save_data_to_json_file()

    def _save_data_to_json_file(self):
        """
        Save generated L1b data to JSON file
        Output file name is set automatically here (TBC if perhaps it should be method argument)
        """
        # define formats for printing values to JSON file
        fmt = {
            'arrays': {
                'direct_event_glows_times': '%.7f',
                'direct_event_pulse_lengths': '%d',
            },
            'scalar variables': {
                'glows_time_last_pps': '%.7f',
                'imap_time_last_pps': '%.7f',
                'imap_time_next_pps': '%.7f',
                'filter_temperature': '%.2f',
                'hv_voltage': '%.1f',
                'spin_period': '%.7f',
                'spin_phase_at_next_pps': '%.7f',
            },
        }

        # create local copy for printing purposes
        data = copy.deepcopy(self.data)

        for key in fmt['arrays'].keys():
            if type(data[key]) == np.ndarray: # check if we have more than one direct event
                data[key] = '[' + ', '.join(map(lambda x: fmt['arrays'][key] % x, list(data[key]))) + ']'
            else:
                data[key] = '[' + fmt['arrays'][key] % data[key] + ']'
        for key in fmt['scalar variables'].keys():
            data[key] = '|'+ fmt['scalar variables'][key] % data[key] +'|'

        # generate JSON content to be saved in output file
        json_content = json.dumps(data, indent=4, default=vars)

        # some corrections to get numbers back
        json_content = json_content.replace('"[', '[').replace(']"', ']')
        json_content = json_content.replace('|"', '').replace('"|', '')
        #json_content = json_content.replace('\\"', '"')

        # start_time_utc string for output file name, based on unique_block_identifier
        start_time_utc = ''.join(filter(str.isdigit, self.data['unique_identifier']))

        # the output file name is constructed using a convention defined in Sec. 1.4.2 of
        # "IMAP SDC to Instrument Team ICD"
        file_name = 'data_l1b_direct_events/imap_glows_l1b_%s_orbX_modX_p_v00.json' % \
                    (start_time_utc)

        file_handler = open(file_name, 'w')
        print(json_content, file=file_handler)
        file_handler.close()

    def set_times(self, l1a_data):
        """
        Set times
        Args:
            l1a_data: L1a data provided in the form of data field of L1aDataDirectEvents object
        """
        self.data['imap_time_last_pps'] = \
            time_sec_subsec_to_float64(l1a_data['data_every_second']['imap_sclk_last_pps'], 0)
        self.data['imap_time_next_pps'] = \
            time_sec_subsec_to_float64(l1a_data['data_every_second']['imap_sclk_next_pps'], 0)
        self.data['glows_time_last_pps'] = \
            time_sec_subsec_to_float64(l1a_data['data_every_second']['glows_sclk_last_pps'],
                                       l1a_data['data_every_second']['glows_ssclk_last_pps'])
